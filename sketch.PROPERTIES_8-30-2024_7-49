import time
import math

import csv
import re


# global variable 
value = 1

controlDown = False
shiftDown = False

degree_symbol = u"\N{DEGREE SIGN}"

total_distance = 0

relative_point = [0,0]

count = 0
order = []

distances = []
degrees = []
# function to setup size of
# output window
def setup():    
    background(255)
    
    image(loadImage("submerged.jpg"), 0, 0, 2362 * 2/3, 1143 * 2/3)
    
    size(2362 * 2/3, 1143 * 2/3 + 100)
    
    # Toolbar
    image(loadImage("download_button.jpg"), 0, 1143 * 2/3, 100, 100) # Download Button
    image(loadImage("connect.jpg"), 100, 1143 * 2/3, 100, 100) # Connect Button
    image(loadImage("calculate.jpg"), 200, 1143 * 2/3, 100, 100) # Calculate Button
    
    #image(loadImage("upload.jpg"), 100, 1143 * 2/3, 100, 100)
    #selectInput("Select a file to process:", "fileSelected")
    
# def fileSelected(selection):
#     print("selection")
#     if selection == None:
#         print("Window was closed or the user hit cancel.")
#     else:
#         print("selected")
#         image(loadImage(selection.getAbsolutePath(), 0, 0, 2362 * 2/3, 1143 * 2/3))
    
# function to draw on the window 
def draw(): 
    # referring to the global value 
    global value 
    
    # if mouse is dragged then 
    # the value will be set to 0 
    # so here by checking if value equal to 0, 
    # we are confirming that the mouse is being 
    # dragged 
    if value == 0:
        if order:
            global count
            global relative_point
            
            # width of circle 
            r = 10
        
            # to fill the color of circle to black 
            fill(0) 
        
            # to create a circle at the position of 
            # mouse clicked mouseX and mouseY coordinates 
            # represents x and y coordinates of mouse 
            # respectively when it is being dragged. 
            ellipse(mouseX, mouseY, r, r)
            
            count += 1
            
            order.append([mouseX, mouseY])
            
            txt = "(" + str(mouseX * 3/2 - relative_point[0] * 3/2) + ", " + str(-1 * (mouseY * 3/2 - relative_point[1] * 3/2)) + ")" + "\n" + str(count)
            
            text(txt, mouseX + 15, mouseY)
            
            # setting value to 1, which means a circle 
            # is drawn at current position and waiting 
            # for the mouse to be clicked. 
            value = 1
        else:
            global count
            global relative_point
            
            # width of circle 
            r = 10
        
            # to fill the color of circle to black 
            fill(0) 
        
            # to create a circle at the position of 
            # mouse clicked mouseX and mouseY coordinates 
            # represents x and y coordinates of mouse 
            # respectively when it is being dragged. 
            ellipse(mouseX, mouseY, r, r)
            
            count += 1
            
            order.append([mouseX, mouseY])
            
            txt = "(0, 0)\n1"
            
            text(txt, mouseX + 15, mouseY)
            
            relative_point = [mouseX, mouseY]
            
            # setting value to 1, which means a circle 
            # is drawn at current position and waiting 
            # for the mouse to be clicked. 
            value = 1
    
    # this function is called when 
    # mouse is being dragged (mouse click+ hold + move) 
    # def mouseDragged(): 
    
    #   # referring to global value 
    #   global value 
    
    #   # setting value to 0 
    #   value = 0

def mousePressed():
    global total_distance
    
    if mouseY < 1143 * 2/3:
        # referring to global value 
        global value 

        # setting value to 0 
        value = 0
    elif mouseX < 100: # Download Button Click
        global order
        
        # open file
        with open('C:/Users/6052h/Downloads/order.txt', 'w+') as f:
            
            # write elements of list
            for item in order:
                f.write('%s\n' %item)
            
            print(order)
            print("File written successfully")
        
        # close the file
        f.close()
        
        with open('C:/Users/6052h/Downloads/distances.txt', 'w+') as f:
            
            # write elements of list
            for item in distances:
                f.write('%s\n' %item)
            
            print(order)
            print("File written successfully")
        
        # close the file
        f.close()
        
        with open('C:/Users/6052h/Downloads/degrees.txt', 'w+') as f:
            
            # write elements of list
            for item in degrees:
                f.write('%s\n' %item)
            
            print(order)
            print("File written successfully")
        
        # close the file
        f.close()
        
    elif 100 < mouseX < 200: # Connect Button Click
        total_distance = 0
        for first, second in zip(order[:-1], order[1:]): # Make line between points
            distance = sqrt((second[0] - first[0])**2 + (second[1] - first[1])**2)
            distance = round(distance, 2)
            distances.append([first, second, distance])
            line(first[0], first[1], second[0], second[1])
            
            label_x = (first[0] + second[0])/2
            label_y = (first[1] + second[1])/2
            
            total_distance += distance
            
            text(str(round(total_distance * 3/2 * (1 + 7 / 23), 2)) + " RP", label_x - 5, label_y - 5)
            
        for first, second, third in zip(order[:-2], order[1:-1], order[2:]): # Make angles for lines that intersect
            m1 = float(second[1] - first[1]) / float(second[0] - first[0])
            m2 = float(third[1] - second[1]) / float(third[0] - second[0])
            
            angle_radians = math.atan(abs((m2 - m1) / (1 + m1 * m2)))
            angle_degrees = angle_radians * 180 / math.pi
            
            global degree_symbol
            
            text(str(round(angle_degrees, 2)) + degree_symbol, second[0] - 20, second[1] - 20)
            
            degrees.append([first, second, third, round(angle_degrees, 2)])
            
    elif 200 < mouseX < 300:
        global total_distance
            
        fill(255)
        square(300, 1143 * 2/3, 100)
        fill(0)
        
        text(str(round(total_distance * 3/2 * (1 + 7 / 23), 2)) + " RP,\n" + str(round(total_distance * 1/50, 2)) + " seconds", 305, mouseY)
        
    elif 300 < mouseX < 400:
        pattern = re.compile(r"([0-9]*);([0-9]*\.?[0-9]*);([0-9]*\.?[0-9]*)", re.IGNORECASE)
        List = []

        with open("collect-perfect.csv") as file:
            csv_reader = csv.reader(file)

            for row in csv_reader:
                result = pattern.match(row[0])
        
                if result:
                    List.append([result.group(1), result.group(2), result.group(3)])
        #print(List)
        global relative_point
        
        last_point = relative_point
        
        for group in List:
            print("for loop")
            if group[1]:
                line(last_point[0], last_point[1] * -1, last_point[0], (float(last_point[1]) + float(group[1])) * -1)
                print("passed line")
                last_point = [last_point[0], (float(last_point[1]) + float(group[1])) * -1]
            else:
                pass
            
def undo():
    if not distances:
        if order:
            global count
            global relative_point
            
            order.pop()
            
            image(loadImage("submerged.jpg"), 0, 0, 2362 * 2/3, 1143 * 2/3)
        
            count = 0
    
            for group in order:
                count += 1
                
                ellipse(group[0], group[1], 10, 10)
                
                txt = "(" + str(group[0] * 3/2 - relative_point[0] * 3/2) + ", " + str(-1 * (group[1] * 3/2 - relative_point[1] * 3/2)) + ")" + "\n" + str(count)
                
                text(txt, group[0] + 15, group[1])


def keyPressed():
    global controlDown
    global shiftDown
    
    if key == "z":
        undo()
